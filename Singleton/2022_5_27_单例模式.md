# 单例模式

## 什么是单例模式

单例模式（Singleton），保证一个类仅有一个实例，并提供一个访问它的全局访问点。--大话设计模式

## 应用场景

保证一个类只有一个实例

- 如Windows下的任务管理器，回收站等。

- 日志管理，计数器等。

> 简而言之，你需要唯一实例时就可以考虑单例模式。这样它可以严格地控制客户怎样访问即何时访问它，即对唯一实例的受控访问。

## 优缺点

优点

- 减少内存开销，因为在系统中只有一个实例。
- 避免了频繁的创建和销毁对象，提高了性能
- 避免对资源的多重占用，比如单例时多人只写一个日志文件，如果有多个日志文件可能导致对相同的日志文件进行写操作
- 设置全局访问点

缺点

- 职责过重，与单一职责存在冲突
- 不能继承（构造方法私有）

## 实现

单例模式有两种实现模式，懒汉模式和饿汉模式。

注意单例模式的概念，大概就是唯一实例且有全局访问点，我们从这两点入手。

唯一实例：构造函数私有+防拷贝

> 拷贝构造是一种构造方式，所以需要防止，构造函数私有不让别人new。

全局访问点：给一个公共的接口

### 饿汉模式

简单来说，把东西一开始就做好，需要的时候直接吃。

```c++
#include <iostream>
using namespace std;

class Singleton
{
public:
	static Singleton& GetInstance()
	{
		return _instance;
	}
	int GetRandom()//由于侧重点不是随机数 所以直接返回一个30
	{
		return 30;
	}
private:
	Singleton() {}//构造函数私有
	Singleton(Singleton&) = delete;//防拷贝，被=delete修饰表明这个函数被删除，即可以只声明不实现,换言之禁用了该函数
	Singleton& operator=(const Singleton&) = delete;//防拷贝
	static Singleton _instance;
};

Singleton Singleton::_instance;
int main()
{
	//1.调用
	cout<<Singleton::GetInstance().GetRandom()<<endl;
	//2.
	Singleton& s = Singleton::GetInstance();
	cout<<s.GetRandom()<<endl;
	return 0;
}
```

通过防拷贝和构造函数私有化之后下面的几种办法都失效了

```c++
Singleton s;//err
Singleton s1(s);//err
Singleton s1=s;//err
```

从上面我们可以看出饿汉模式的优缺点了，有点显而易见就是实现很简单粗暴，缺点很明显，类加载时单例对象就已经生成了，即还没有用就已经加载出来了，比如这个资源很大，又在游戏启动时加载，那就会造成游戏启动很慢。且如果有多个单例对象启动时实例化顺序不确定（不同源文件类内的单例对象实例化顺序是不确定的，懒汉模式解决了这个问题，因为懒汉模式的实例化在函数内部，可以通过调用函数的顺序来解决实例化的顺序问题）。

### 懒汉模式

什么时候需要什么时候做，然后吃。





特殊类设计



设计一个类只能在堆上创建对象  两种办法 选后一种

this不能置空  被const修饰

通过拷贝构造构造在栈上的对象-->拷贝构造



C++11 =delete



只能在栈上创建对象

重载new（可以在静态区上创建是一个缺陷）和禁掉所有方式来搞





一个类不能被继承

![image-20220529110525378](https://pic-1304888003.cos.ap-guangzhou.myqcloud.com/img/image-20220529110525378.png)



全局唯一

.h不能包含定义,不然多个cpp去包含就会有链接错误

而是把定义和声明分离开来



[【82】【Cherno C++】【中字】C++的单例模式_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1bR4y177Hp?spm_id_from=333.999.0.0)



懒汉模式和饿汉模式



解决了控制依赖依赖/启动慢的问题（谁先谁后的问题）

懒汉采用指针



懒汉可能因为多线程丢数据，线程加锁保证在多线程环境下一定只有一个线程去new对象，只创建出一个单例对象



加锁可能导致频繁切换上下文，双检查加锁解决

main之前可以认为没有多线程





懒汉就得控制线程安全



饿汉不好释放 因为成员是对象

懒汉好释放，因为成员是指针